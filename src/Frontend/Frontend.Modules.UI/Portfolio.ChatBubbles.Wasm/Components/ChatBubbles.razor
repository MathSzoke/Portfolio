@using System.Net.Http.Json
@using System.Text.Json
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.JSInterop
@using Portfolio.ChatBubbles.Wasm.Models

<style>
    .bubbles {
        display: flex;
        flex-direction: column;
        gap: 12px;
        width: 100%;
        height: 100%;
        box-sizing: border-box
    }

    .row {
        display: flex
    }

        .row.right {
            justify-content: flex-end
        }

        .row.left {
            justify-content: flex-start
        }

    .bubble {
        max-width: 60%;
        padding: 10px 12px;
        border-radius: 14px;
        font-size: 14px;
        line-height: 1.4;
        word-break: break-word;
        white-space: pre-wrap
    }

    .right .bubble {
        background: #5AA268;
        color: #fff;
        border-bottom-right-radius: 6px
    }

    .left .bubble {
        background: #68809d;
        color: #fff;
        border-bottom-left-radius: 6px
    }

    .thinking {
        display: inline-flex;
        gap: 6px;
        align-items: center
    }

    .dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #fff;
        opacity: .7;
        animation: blink 1s infinite
    }

        .dot:nth-child(2) {
            animation-delay: .2s
        }

        .dot:nth-child(3) {
            animation-delay: .4s
        }
    @@keyframes blink {
        0%, 80%, 100% {
            opacity: .2
        }

        40% {
            opacity: 1
        }
    }
</style>

<div class="bubbles">
    @foreach (var m in messages)
    {
        var cls = m.SenderUserId == SenderUserId ? "right" : "left";
        <div class="row @cls">
            <div class="bubble">@m.Content</div>
        </div>
    }
    @if (thinking)
    {
        <div class="row left">
            <div class="bubble">
                <span class="thinking"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public string? Api { get; set; }
    [Parameter] public string? SessionId { get; set; }
    [Parameter] public string? SenderUserId { get; set; }
    [Parameter] public string? AuthToken { get; set; }
    [Parameter] public string ChatHubPath { get; set; } = "/hubs/chat";

    List<ChatMessageDto> messages = new();
    HubConnection? hub;
    string? lastApi;
    string? lastSession;
    bool thinking;
    bool starting;

    [Inject] HttpClient Http { get; set; } = default!;
    [Inject] IJSRuntime JS { get; set; } = default!;

    private sealed class ChatMessagesEnvelope
    {
        public string SessionId { get; set; } = string.Empty;
        public List<ChatMessageItem> ChatMessageItems { get; set; } = new();
    }
    private sealed class ChatMessageItem
    {
        public string Id { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
        public string Sender { get; set; } = string.Empty;
        public string SenderUserId { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; }
        public DateTime? ReadAt { get; set; }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (string.IsNullOrWhiteSpace(Api) || string.IsNullOrWhiteSpace(SessionId)) return;
        if (Api == lastApi && SessionId == lastSession) return;
        lastApi = Api;
        lastSession = SessionId;
        await DisposeHub();
        messages = new();
        thinking = false;
        StateHasChanged();
        await NotifyUpdated();
        await NotifyThinking();
        _ = WaitTokenThenStart(Api, SessionId);
    }

    async Task WaitTokenThenStart(string api, string session)
    {
        if (starting) return;
        starting = true;
        var attempts = 0;
        while (attempts < 20 && string.IsNullOrWhiteSpace(AuthToken))
        {
            attempts++;
            await Task.Delay(100);
        }
        if (api != Api || session != SessionId)
        {
            starting = false;
            return;
        }
        await FetchMessages();
        await EnsureHub();
        starting = false;
    }

    async Task FetchMessages()
    {
        if (string.IsNullOrWhiteSpace(Api) || string.IsNullOrWhiteSpace(SessionId)) return;
        var url = $"{Api}/api/v1/chat/sessions/{SessionId}/messages";
        try
        {
            using var req = new HttpRequestMessage(HttpMethod.Get, url);
            if (!string.IsNullOrWhiteSpace(AuthToken))
                req.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", AuthToken);
            var resp = await Http.SendAsync(req);
            var body = await resp.Content.ReadAsStringAsync();
            if (!resp.IsSuccessStatusCode || string.IsNullOrWhiteSpace(body))
            {
                messages = new();
                thinking = false;
                StateHasChanged();
                await NotifyUpdated();
                await NotifyThinking();
                return;
            }
            var opts = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            var env = JsonSerializer.Deserialize<ChatMessagesEnvelope>(body, opts);
            messages = (env?.ChatMessageItems ?? new())
                .Select(i => new ChatMessageDto
                {
                    Id = i.Id,
                    SessionId = env?.SessionId ?? SessionId ?? string.Empty,
                    Sender = i.Sender,
                    SenderUserId = i.SenderUserId,
                    Content = i.Content,
                    CreatedAt = i.CreatedAt,
                    ReadAt = i.ReadAt
                })
                .ToList();
            var last = messages.LastOrDefault();
            thinking = last != null && last.Sender == "Visitor";
            StateHasChanged();
            await NotifyUpdated();
            await NotifyThinking();
        }
        catch
        {
            messages = new();
            thinking = false;
            StateHasChanged();
            await NotifyUpdated();
            await NotifyThinking();
        }
    }

    async Task EnsureHub()
    {
        if (string.IsNullOrWhiteSpace(Api) || string.IsNullOrWhiteSpace(SessionId)) return;

        var hubUrl = $"{Api}{ChatHubPath}";
        var builder = new HubConnectionBuilder()
            .WithUrl(hubUrl, options =>
            {
                if (!string.IsNullOrWhiteSpace(AuthToken))
                    options.AccessTokenProvider = () => Task.FromResult<string?>(AuthToken);
            })
            .WithAutomaticReconnect();

        hub = builder.Build();

        hub.On<ChatMessageDto>("MessagePosted", async m =>
        {
            if (string.IsNullOrWhiteSpace(m.SessionId)) m.SessionId = SessionId ?? m.SessionId;
            if (m.SessionId == SessionId)
            {
                messages.Add(m);
                thinking = m.Sender == "Visitor";
                await InvokeAsync(StateHasChanged);
                await NotifyUpdated();
                await NotifyThinking();
            }
        });

        hub.On<object>("MessageRead", async payload =>
        {
            await InvokeAsync(StateHasChanged);
        });

        hub.Reconnected += async _ =>
        {
            try { await hub.InvokeAsync("JoinSession", SessionId); } catch { }
        };

        await hub.StartAsync();
        try { await hub.InvokeAsync("JoinSession", SessionId); } catch { }
    }

    async Task DisposeHub()
    {
        if (hub is null) return;
        try { await hub.StopAsync(); } catch { }
        try { await hub.DisposeAsync(); } catch { }
        hub = null;
    }

    Task NotifyUpdated() =>
        JS.InvokeVoidAsync("eval", "window.dispatchEvent(new CustomEvent('chat-bubbles-updated'))").AsTask();

    Task NotifyThinking()
    {
        var payload = JsonSerializer.Serialize(new { detail = new { sessionId = SessionId ?? "", thinking } });
        return JS.InvokeVoidAsync("eval", $"window.dispatchEvent(new CustomEvent('chat-bubbles-thinking', {payload}));").AsTask();
    }

    public async ValueTask DisposeAsync() => await DisposeHub();
}
